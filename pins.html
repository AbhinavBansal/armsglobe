<!doctype html>
<html lang="en">
	<head>
		<title>Arms Trade</title>
		<meta charset="utf-8">
		<meta name="viewport" content="user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="style.css">

		<style>
			#dataviz { 				
				background-color: 	#000000;
				margin: 			0px;
				overflow: 			hidden;
			}
			#iff{
				-webkit-perspective:		800;
				position:					absolute;
				margin: 					0px;
				width:						100%;
				height:						100%;
				pointer-events:				none;
			}			
		</style>


		<script>

			var controllers = {
				category: 		"All",
				speed: 			3,							
				multiplier: 	0.5,
				lineWidth: 		2,		
				useOpacity: 	false,	
				opacityAmount: 	1,
				hueDiff: 		0.03,
				borderColor: 	"#6b647d",
				sphereColor: 	"#090903",
				backgroundColor:"#000000",
				textColor: 		"#ffffff",
				baseSize: 		165,
				ignoreUS: 		false,		
				zoom: 			1,
				spin: 			0,
				transitionTime: 2000,
				con: 			"",
			};	
			
			//	location of the data files we're going to load
			var globePinsFile = "globe_pins_wide_distributed.json"		//	an evenly spaced version of the pins globe

			//	contains a list of country codes with their matching country names
			var isoFile = "country_iso3166.json";
						
		</script>
	</head>

	<body onload="start()" id="dataviz" class="">

		<script src="js/Tween.js"></script>		
		<script src="js/dat.gui.min.js"></script>
		<script src="js/Three.js"></script>
		<script src="js/THREEx.KeyboardState.js"></script>
		<script src="js/THREEx.WindowResize.js"></script>
		<script src="js/Stats.js"></script>
		<script src="js/jquery-1.7.1.min.js"></script>
		<script src="js/RequestAnimationFrame.js"></script>	
		<script src="js/ShaderExtras.js"></script>
		<script src="js/canvg.js"></script>
		<script src="js/rgbcolor.js"></script>
		<script src="js/innersvg.js"></script>

		<script src="js/geopins.js"></script>
		<script src="js/visualize.js"></script>
		<script src="js/visualize_lines.js"></script>
		<script src="js/svgtoy.js" type="text/javascript"></script>	


		<script type="x-shader/x-vertex" id="vertexshader">

			uniform float amplitude;
			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size;
				// gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

			}

		</script>

		
		<script>		

			THREE.Curve.Utils.createLineGeometry = function( points ) {
				var geometry = new THREE.Geometry();
				for( var i = 0; i < points.length; i ++ ) {
					geometry.vertices.push( points[i] );
				}
				return geometry;
			};

			var debugUI = gup("debugUI")==1;

		    var camera, scene, renderer, controls,
		    geometry, material, colors;
		    var pickRenderer;

			var mouseX = 0, mouseY = 0, pmouseX = 0, pmouseY = 0;
			var pressX = 0, pressY = 0;

			var frameCount = 0;	 
			var dragging = false;						

			var rotateX = 0, rotateY = 0;
			var rotateVX = 0, rotateVY = 0;
		    var rotateXMax = 90 * Math.PI/180;			
			
		    var pinsBase, pinsBaseMat;
		    var backMat;
		    var backTexture;
		    var worldCanvas;
		    var sphere;
			var rotating;	
			var visualizationMesh;		

			var countryLookup;			
			var countryData = new Object();				

			var timeBins;
			var pinsdata;
			var maxValue = 0;			
			var time = 0;		
			var startTime = 0;
	    	var endTime = 0;
	    	var timeLength = 0;
		    var frameWait = controllers.speed;					    		    			    
		   
		    var colorLookup = new Object();			//	used for picking
		    
		    var selectedCountry = null;				//	the currently selected country

			var uniforms, attributes;

		    //	histogram objects
		    var histogramSVG;
		    var histogramPlayhead = 0;
		    var histogramPath;
		    var histogramCirclesGroup;
		    var histogramCountryText;
		    var histogramBorder;
		    var hWidth = window.innerWidth;
		    var hHeight = window.innerHeight * 0.15;		
		    var histogramPressed = false;   
		    
		    var playing = false;
		    var idle = false;

		    var displayedCategoryName = "";

			var conOut;		
			var zoomController;    
			var categoryController;
			var spinController;
			var playbackSpeedController;
			var keyboard	= new THREEx.KeyboardState();

			var debugVisible = true;
			var gui;

			var cameraStates = new Object();
			var currentCameraState = null;
			var targetCameraState = null;

			var defaultCameraState;

			var selectedFade = 1;

			var assetList = [	"images/crosshair.svg", 'images/worldmap_equirectangular_simplified.svg'	];


			var masterContainer = document.createElement('div');
			document.body.appendChild( masterContainer );

			var iff = document.createElement('div');
			iff.id = "iff";
			masterContainer.appendChild(iff);	

			function start(){}
			//	only load the data file once we've loaded our world pins
			function start( e ){
				loadSVGAssets( assetList,
					function(){
						loadCountryCodes(
							function(){
								loadWorldPins(
									function(){										
										loadContentData(
											controllers.category,
											function(){																	
												initScene();
												animate();		
												// cycleData();
											}
										);
																		
										time = 0;							
									}
								);
							}
						);
					}
				);
			}			
		    
		    function loadWorldPins( callback ){							
				// We're going to ask a file for the JSON data.
				xhr = new XMLHttpRequest();

				// Where do we get the data?
				xhr.open( 'GET', 'country_lat_lon.json', true );

				// What do we do when we have it?
				xhr.onreadystatechange = function() {
				  // If we've received the data
				  if ( xhr.readyState === 4 && xhr.status === 200 ) {
				      // Parse the JSON
				      pinsdata = JSON.parse( xhr.responseText );
				      if( callback )
				      	callback();				     
				    }
				};

				// Begin request
				xhr.send( null );			    	
		    }

		    function loadContentData(categoryName, callback){	
		    	var filePath = "categories/" + categoryName + ".json";
		    	filePath = encodeURI( filePath );
		    	console.log(filePath);
		    			
				xhr = new XMLHttpRequest();
				xhr.open( 'GET', filePath, true );
				xhr.onreadystatechange = function() {
					if ( xhr.readyState === 4 && xhr.status === 200 ) {
				    	timeBins = JSON.parse( xhr.responseText ).timeBins;
					
						maxValue = 0;
						console.log(timeBins);

						startTime = timeBins[0].t;
				    	endTime = timeBins[timeBins.length-1].t;
				    	timeLength = endTime - startTime;				    											    	

						if(callback)
							callback();		
							
						displayedCategoryName = categoryName;					

				    	console.log("finished read data file");	   	
				    }
				};
				xhr.send( null );					    	
		    }


			var Selection = function(){
				this.selectedYear = '1992';
				this.selectedCountry = 'United States';
				this.showExports = true;
				this.showImports = true;
				this.importExportFilter = 'both';

				this.categories = new Object();
				for( var i in weaponLookup ){
					this.categories[i] = true;
				}				

				this.getCategories = function(){
					var list = [];
					for( var i in this.categories ){
						if( this.categories[i] )
							list.push(i);
					}
					return list;
				}
			};

		    function buildGUI(){	
		    	var selection = new Selection();

		    	var updateVisualization = function(){
		    		var categories = selection.getCategories();		    		
		    		selectVisualization( timeBins, selection.selectedYear, [selection.selectedCountry], selection.importExportFilter, categories );	
		    	}		    	

				var changeFunction = function(v){
					updateVisualization();
				}	

				var filterFunction = function(v){
					if( selection.showExports && !selection.showImports )
						selection.importExportFilter = 'exports';
					else
					if( !selection.showExports && selection.showImports )
						selection.importExportFilter = 'imports';
					else
					if( selection.showExports && selection.showImports )
						selection.importExportFilter = 'both';
					else
						selection.importExportFilter = 'none';

					updateVisualization();	
				}	    	

				var categoryFunction = function(v){
					var selectedCategories = selection.getCategories();
					updateVisualization();
				}

		    	var gui = new dat.GUI();
		    	var c = gui.add( selection, 'selectedYear', selectableYears );
		    	c.onFinishChange( changeFunction );

				c = gui.add( selection, 'selectedCountry', selectableCountries );
				c.onFinishChange( changeFunction );		

				c = gui.add( selection, 'showExports' );
				c.onFinishChange( filterFunction );

				c = gui.add( selection, 'showImports' );
				c.onFinishChange( filterFunction );

				var catFilter = gui.addFolder('Weapon Types');
				for( var i in selection.categories ){
					var catSwitch = selection.categories[i];
					c = catFilter.add( selection.categories, i );	
					c.onFinishChange( categoryFunction );
				}
				
		    }


		    function loadCountryCodes( callback ){
		    	cxhr = new XMLHttpRequest();
				cxhr.open( 'GET', isoFile, true );
				cxhr.onreadystatechange = function() {
					if ( cxhr.readyState === 4 && cxhr.status === 200 ) {
				    	countryLookup = JSON.parse( cxhr.responseText );		    	
				    	console.log("loaded country codes");
				    	callback();
				    }
				};
				cxhr.send( null );
		    }

		    function initScene() {

		        //	-----------------------------------------------------------------------------
		        //	All the initialization stuff for THREE
		    	//	where in html to hold all our things
				container = document.createElement( 'div' );
				masterContainer.appendChild( container );	
				container.id = 'container';				


		        //	-----------------------------------------------------------------------------
		        //	Setup our renderer
				renderer = new THREE.WebGLRenderer({antialias:false});
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;	
				
				renderer.sortObjects = false;		
				renderer.generateMipmaps = false;					

				container.appendChild( renderer.domElement );							


				//	-----------------------------------------------------------------------------
		        //	Let's make a scene		
				scene = new THREE.Scene();
				scene.matrixAutoUpdate = false;				


		        //	-----------------------------------------------------------------------------
		        //	Event listeners
				document.addEventListener( 'mousemove', onDocumentMouseMove, true );
				document.addEventListener( 'windowResize', onDocumentResize, false );

				masterContainer.addEventListener( 'mousedown', onDocumentMouseDown, true );	
				masterContainer.addEventListener( 'mouseup', onDocumentMouseUp, false );	
				masterContainer.addEventListener( 'click', onClick, false );	
				masterContainer.addEventListener( 'mousewheel', onMouseWheel, false );
				// container.focus();	

				document.addEventListener( 'keydown', onKeyDown, false);												    			    	

		        //	-----------------------------------------------------------------------------
		        //	Setup our camera
		        camera = new THREE.PerspectiveCamera( 12, window.innerWidth / window.innerHeight, 1, 20000 ); 		        
  				camera.position.z = 1400;
  				camera.position.y = 0;
  				camera.lookAt(scene.width/2, scene.height/2);	
  				scene.add( camera );	  

  				var windowResize = THREEx.WindowResize(renderer, camera)	


				// scene.fog = new THREE.FogExp2( 0xBBBBBB, 0.00003 );		        		       

				scene.add( new THREE.AmbientLight( 0x505050 ) );				

				light1 = new THREE.SpotLight( 0xeeeeee, 3 );
				light1.position.x = 730; 
				light1.position.y = 520;
				light1.position.z = 626;
				light1.castShadow = true;
				scene.add( light1 );

				light2 = new THREE.PointLight( 0x222222, 14.8 );
				light2.position.x = -640;
				light2.position.y = -500;
				light2.position.z = -1000;
				scene.add( light2 );				

				rotating = new THREE.Object3D();
				scene.add(rotating);

				//	render a world map
				worldCanvas = document.createElement('canvas');
				worldCanvas.id = 'worldCanvas';
				worldCanvas.width = 1024;
				worldCanvas.height = 1024;				
				

				var start = "<svg x='0px' y='0px' width='4096px' height='2048px' viewBox='-1833.626 -529.136 4096 2048'>";
				var end = "</svg>";

				var loadedSVG = assets['images/worldmap_equirectangular_simplified.svg'];				

				var list = loadedSVG.querySelectorAll( 'path' );
				for( var i in list ){
					var element = list[i];
					if( element.setAttribute === undefined )
						continue;
					element.setAttribute( 'fill', '#222222' );					
					element.setAttribute( 'stroke', '#ffffff' );		
				}

				// console.time('canvg');
				// // canvg( worldCanvas, start + loadedSVG.innerHTML + end, {ignoreClear:true} );	
				// console.timeEnd('canvg');				

		        //	-----------------------------------------------------------------------------
		        //	Create the backing (sphere)
		        var mapGraphic = new THREE.Texture(worldCanvas);//THREE.ImageUtils.loadTexture("images/map.png");
		        backTexture =  mapGraphic;
		        mapGraphic.needsUpdate = true;
				backMat = new THREE.MeshBasicMaterial(
					{
						// color: 		0xffffff, 
						// shininess: 	10, 
    		// 			specular: 	0x333333,
    					map: 		mapGraphic,
    					// lightMap: 	mapGraphic
					}
				);				
				// backMat.ambient = new THREE.Color(255,255,255);							
				sphere = new THREE.Mesh( new THREE.SphereGeometry( 100, 40, 40 ), backMat );				
				sphere.rotation.x = - 90 * Math.PI / 180;
				// sphere.receiveShadow = true;
				// sphere.castShadow = true;
				sphere.doubleSided = false;
				sphere.rotation.x = Math.PI;				
				sphere.rotation.y = Math.PI;
				sphere.rotation.z = Math.PI;
				sphere.id = "base";	
				rotating.add( sphere );	

				for( var i in timeBins ){					
					var bin = timeBins[i].data;
					for( var s in bin ){
						var set = bin[s];
						// if( set.v < 1000000 )
						// 	continue;
						var exporterName = set.e.toUpperCase();
						var importerName = set.i.toUpperCase();

						//	let's track a list of actual countries listed in this data set
						//	this is actually really slow... consider re-doing this with a map
						if( $.inArray(exporterName, selectableCountries) < 0 )
							selectableCountries.push( exporterName );

						if( $.inArray(importerName, selectableCountries) < 0 )
							selectableCountries.push( importerName );
					}
				}

				// console.log( selectableCountries );
				


				// make the world pins
				console.time('makeGeoPins');
				var geography = makeGeoPins( pinsdata );				
				console.timeEnd('makeGeoPins');
				rotating.add( geography );				

				console.time('buildDataVizGeometries');
				var vizilines = buildDataVizGeometries(timeBins);
				console.timeEnd('buildDataVizGeometries');

				visualizationMesh = new THREE.Object3D();
				rotating.add(visualizationMesh);	

				buildGUI();

				selectVisualization( timeBins, '1992', ['United States'], 'both', ['Military Weapons','Civilian Weapons', 'Ammunition'] );				
				highlightCountry( [] );
		    }
				

		    function onDocumentResize(e){
	    		// setHistogram(selectedCountry);
		    }

		    function buildHexColumnGeo(rad, height){
				var points = [];
				var ang = 0;
				var sixth = 2*Math.PI / 6;
				for(var i=0; i<7; i++){					
					var x = Math.cos(ang) * rad;
					var y = -Math.sin(ang) * rad;
					points.push( new THREE.Vector2(x,y) );
					ang += sixth;
				}
				var shape = new THREE.Shape(points);

				var options = {
					size: 			0,
					amount: 		height,
					steps: 			1,
					bevelEnabled:  	false,
				};
				var extrudedGeo = new THREE.ExtrudeGeometry(shape, options);
				return extrudedGeo;	    	
		    }

			function onDocumentMouseMove( event ) {

				pmouseX = mouseX;
				pmouseY = mouseY;

				mouseX = event.clientX - window.innerWidth * 0.5;
				mouseY = event.clientY - window.innerHeight * 0.5;

				if(dragging){
					if(keyboard.pressed("shift") == false){
						rotateVY += (mouseX - pmouseX) / 2 * Math.PI / 180 * 0.3;
		      			rotateVX += (mouseY - pmouseY) / 2 * Math.PI / 180 * 0.3;	
		      		}
		      		else{
		      			camera.position.x -= (mouseX - pmouseX) * .5; 
		      			camera.position.y += (mouseY - pmouseY) * .5;
		      		}
				}
			}

			function onDocumentMouseDown( event ) {	
		        dragging = true;			   
		        pressX = mouseX;
		        pressY = mouseY;   	
			}	

			function onDocumentMouseUp( event ){
				dragging = false;
				histogramPressed = false;
			}

			function onClick( event ){
				//	make the rest not work if the event was actually a drag style click
				if( Math.abs(pressX - mouseX) > 3 || Math.abs(pressY - mouseY) > 3 )
					return;				
			}

			function onKeyDown( event ){	
			}

			function handleMWheel( delta ) {
				camera.scale.z += delta * 0.1;
				camera.scale.z = Math.max( camera.scale.z, 0.2 );
			}

			function onMouseWheel( event ){
				var delta = 0;

				if (event.wheelDelta) { /* IE/Opera. */
				        delta = event.wheelDelta/120;
				} 

				if (delta)
				        handleMWheel(delta);

				event.returnValue = false;			
			}		

		    function animate() {		    	
		    	if(keyboard.pressed('o') && keyboard.pressed('shift') == false)
		    		camera.rotation.z -= 0.08;		    	
				if(keyboard.pressed('p') && keyboard.pressed('shift') == false)
		    		camera.rotation.z += 0.08;		   

		    	rotateX += rotateVX;
		    	rotateY += rotateVY;

		    	rotateVX *= 0.98;
		    	rotateVY *= 0.98;

		    	if(dragging){
		    		rotateVX *= 0.6;
		    		rotateVY *= 0.6;
		    	}	     

		    	rotateY += controllers.spin * 0.01;

		    	//	constrain the pivot up/down to the poles
		    	//	force a bit of bounce back action when hitting the poles
		    	if(rotateX < -rotateXMax){
		    		rotateX = -rotateXMax;
		    		rotateVX *= -0.95;
		    	}
		    	if(rotateX > rotateXMax){
		    		rotateX = rotateXMax;
		    		rotateVX *= -0.95;
		    	}		    			    		   
		   
				TWEEN.update();		
				rotating.rotation.x = rotateX;
				rotating.rotation.y = rotateY;		

		        render();	
		        		        		       
		        requestAnimationFrame( animate );	


				THREE.SceneUtils.traverseHierarchy( rotating, 
					function(mesh) {
						if (mesh.update !== undefined) {
							mesh.update();
						} 
						if (mesh.marker !== undefined ){
							mesh.marker.update();
						}
					}
				);			    	

				// backTexture.needsUpdate = true;
		    }

		    function render() {	
		    	renderer.clear();		    					
		        renderer.render( scene, camera );
		        frameCount++;				
		    }		   

		    function toTHREEColor( colorString ){
		    	return new THREE.Color( parseInt( colorString.substr(1) , 16)  );
		    }

			var monthNames = new Array(12);
			monthNames[0] = "January";
			monthNames[1] = "February";
			monthNames[2] = "March";
			monthNames[3] = "April";
			monthNames[4] = "May";
			monthNames[5] = "June";
			monthNames[6] = "July";
			monthNames[7] = "August";
			monthNames[8] = "September";
			monthNames[9] = "October";
			monthNames[10] = "November";
			monthNames[11] = "December";			

			function toMonthName( monthNumber ){
				return monthNames[monthNumber];
			}	

			function componentToHex(c) {
				var hex = c.toString(16);
				return hex.length == 1 ? "0" + hex : hex;
			}

			function rgbToHex(r, g, b) {
				return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
			}

			function gup( name )
			{
				name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
				var regexS = "[\\?&]"+name+"=([^&#]*)";
				var regex = new RegExp( regexS );
				var results = regex.exec( window.location.href );
				if( results == null )
				return "";
				else
				return results[1];
			}

			function wrap(value, min, rangeSize) {
				rangeSize-=min;
			    while (value < min) {
			    	value += rangeSize;
				}
				return value % rangeSize;
			}

			function attachSVG( object ){
				var randomIndex = Math.floor( Math.random() * assetList.length );
				var svgAsset = assetList[randomIndex];
				var svgToy = new SVGToy( svgAsset, iff );
				// svgToy.setScale( 0.2  );
				object.display = svgToy;				
			}

			function getAbsOrigin( object3D ){
				var mat = object3D.matrixWorld;
				var worldpos = new THREE.Vector3();
				worldpos.x = mat.n14;
				worldpos.y = mat.n24;
				worldpos.z = mat.n34;
				return worldpos;
			}

			function screenXY(vec3){
				var projector = new THREE.Projector();
				var vector = projector.projectVector( vec3.clone(), camera );
				var result = new Object();
				result.x = Math.round( vector.x * (window.innerWidth/2) ) + window.innerWidth/2;
				result.y = Math.round( (0-vector.y) * (window.innerHeight/2) ) + window.innerHeight/2;
				return result;
			}	

			function onMarkerHover( event ){
				var hx = event.clientX - window.innerWidth * 0.5;
				var hy = event.clientY - window.innerHeight * 0.5;
				var dx = mouseX - hx;
				var dy = mouseY - hy;
				var d = Math.sqrt( dx * dx + dy * dy );
				if( event.target.style.visibility == 'visible' )
					console.log('clicked on something!!');				
			}

			function attachMarkerToCountry( countryName ){
				//	look up the name to mesh
				countryName = countryName.toUpperCase();
				var mesh = countryData[countryName];
				if( mesh === undefined )
					return;
				mesh.marker = new SVGToy( assetList[0], iff );
				mesh.marker.update = function(){
					var matrix = rotating.matrixWorld;
					var abspos = matrix.multiplyVector3( mesh.center.clone() );
					var screenPos = screenXY(abspos);
					mesh.marker.setPosition( screenPos.x, screenPos.y,0 );	
					if( abspos.z > 60 )
						mesh.marker.show();
					else
						mesh.marker.hide();
				}

				mesh.marker.svg.parentMesh = mesh;
				mesh.marker.svg.addEventListener( 'click', onMarkerHover, false );

			}		

			function removeMarkerFromCountry( countryName ){
				countryName = countryName.toUpperCase();
				var mesh = countryData[countryName];
				if( mesh === undefined )
					return;
				if( mesh.marker === undefined )
					return;
				mesh.marker.removeFromDom();
				mesh.marker = undefined;				
			}

			function findCode(countryName){
				countryName = countryName.toUpperCase();
				for( var i in countryLookup ){
					if( countryLookup[i] === countryName )
						return i;
				}
				return 'not found';
			}

			function highlightCountry( countries ){				
				var countryCodes = [];
				for( var i in countries ){
					var code = findCode(countries[i]);
					countryCodes.push(code);
				}

				var start = "<svg x='0px' y='0px' width='4096px' height='2048px' viewBox='-1833.626 -529.136 4096 2048'>";
				var end = "</svg>";

				var loadedSVG = assets['images/worldmap_equirectangular_simplified.svg'];				

				var list = loadedSVG.querySelectorAll( 'path' );
				for( var i in list ){
					var element = list[i];
					if( element.setAttribute === undefined )
						continue;
					element.setAttribute( 'fill', '#222222' );					
					element.setAttribute( 'stroke', '#ffffff' );		
				}
				
				for( var i in countryCodes ){
					//	well.. country codes in the svg are lower case so..
					var code = countryCodes[i].toLowerCase();
					var selected = loadedSVG.getElementById(code);
					if( selected === undefined || selected === null ){
						console.log(selected);
						continue;
					}
						
					if( selected.setAttribute === undefined ){
						continue;
					}
					selected.setAttribute('visibility', 'visible' );
					list = selected.querySelectorAll( 'g,path' );				
					for( var s in list ){
						var element = list[s];
						if( element.setAttribute === undefined )
							continue;
						element.setAttribute('fill', '#ff0000');
					}							
				}				

				console.time('canvg');
				canvg( worldCanvas, start + loadedSVG.innerHTML + end );	
				console.timeEnd('canvg');
				backMat.needsUpdate = true;			
			}

		</script>

	</body>
</html>	